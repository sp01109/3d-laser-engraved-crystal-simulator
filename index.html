<!DOCTYPE html>
<html>
<head>
<!-- CSS Styles -->
<link rel="stylesheet" type="text/css" href="css/style.css">
<!-- GUI Libraries -->
<script type="text/javascript" src="js/dat.gui.min.js"></script>
<!-- MATH Libraries -->
<script type='text/javascript' src='js/gl-matrix-min.js'></script>
<!-- WEBGL Libraries -->
<script type='text/javascript' src='js/webgl/Globals.js'></script>
<script type='text/javascript' src='js/webgl/Utils.js'></script>
<script type='text/javascript' src='js/webgl/Program.js'></script>
<script type='text/javascript' src='js/webgl/Scene.js'></script>
<script type='text/javascript' src='js/webgl/Camera.js'></script>
<script type='text/javascript' src='js/webgl/CameraInteractor.js'></script>
<script type='text/javascript' src='js/webgl/WebGLApp.js'></script>
<!-- Object file loader -->
<script type="text/javascript" src="js/webgl-obj-loader/webgl-obj-loader.js"></script>
<!-- Shading Part (Main implementation)-->
<script type="text/javascript" src="js/WebGLMain.js"></script>
<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec2 aVertexPosition;
	attribute vec3 aPlotPosition;

	varying vec3 vPixelPosition;  

	void main(void){
		gl_Position = vec4(aVertexPosition, 1.0, 1.0);
		vPixelPosition = aPlotPosition; 
	}
</script>
<script id="shader-fs" type="x-shader/x-fragment">
	precision mediump float;

	//camera position
	uniform vec3 uCameraPosition;

	//lights
	uniform vec3 uLightPosition; 
	uniform vec4 uLightAmbient;  
	uniform vec4 uLightDiffuse;
	const vec3 lightDir = vec3(0.0, 1.0, 0.0);

	//spheres
    //uniform vec3 uSphereCenters[10];
    uniform float uSphereRadius; //radius

    //triangles/object
    uniform int uVerticesNumber;
    uniform int uInticesNumber;
    uniform sampler2D uTriangleVertices;
    uniform sampler2D uTriangleIndices;

	//this pixel's position
	varying vec3 vPixelPosition; 

	bool intersectSphere(vec3 center, vec3 lightStart, vec3 rayDir, out float dist) {
	    vec3 c = center - lightStart;
	    float b = dot(rayDir, c);
	    float d = b*b - dot(c, c) + 1.0;
	    //float d = b*b - dot(c, c) + uSphereRadius*uSphereRadius;

	    if (d < 0.0) {
	      dist = 10000.0;
	      return false;
	    }

	    dist = b - sqrt(d);
	    if (dist < 0.0) {
	      dist = 10000.0;
	      return false;
	    }

	    return true;
	}

	bool intersectTriangle(in vec3 A, in vec3 B, in vec3 C
						 , in vec3 lightStart, in vec3 rayDir
						 , out vec3 intersectPoint){
		intersectPoint = vec3(0.0, 0.0, 0.0);
		//vec3 u = B-A;
		//vec3 v = C-A;
		//vec3 N = cross(u, v);
		vec3 N = vec3(0.0,0.0,0.0);
		float a = -dot(N, lightStart-A);
		float b = dot(N, rayDir);
		
		if(b<0.000001) return false; //parralle

		// get intersect point of ray with triangle plane
		float r = a/b;
    	if (r < 0.0) return false;// ray goes away from triangle => no intersect
    
    	// for a segment, also test if (r > 1.0) => no intersect
    	intersectPoint = lightStart + rayDir * r;

    	// is the point inside triangle ?
    	float uu = dot(u,u);
    	float uv = dot(u,v);
    	float vv = dot(v,v);
    	vec3 w = intersectPoint - A;
    	float wu = dot(w,u);
    	float wv = dot(w,v);
    	float D = uv * uv - uu * vv;

    	// get and test parametric coords
    	float s = (uv * wv - vv * wu) / D;
    	if (s < 0.0 || s > 1.0) return false; // I is outside T
    	float t = (uv * wu - uu * wv) / D;
    	if (t < 0.0 || (s + t) > 1.0) return false; // I is outside T
   
		return true; // I is in T
	}

	vec3 lightAt(vec3 N, vec3 E, vec3 color) {
		vec3 L = normalize(lightDir);
		vec3 R = reflect(-L, normalize(N));

		//ks, kd
		float c = 0.4 * pow(max(dot(R, E), 0.0), 30.0) + 0.7 * dot(L, normalize(N));

		if (c > 1.0) {
		  //??? 1.6
		  return mix(color, vec3(1.6, 1.6, 1.6), c - 1.0);
		}
		//add ka
		return 0.1*normalize(vec3(1.0,1.0,1.0))+ c * color;
	}

	/**
	* lightStart: light's start position (eg: camera's postion at beginning)
	* rayDir:    vector of the ray from camera via pixel
	* pos:       the surface's position in the world
	* normal:    object surface's normal vector
	* color:     the color on the object's surface
	*/
	bool intersectWorld(in vec3 lightStart, in vec3 rayDir, 
                      	out vec3 pos, out vec3 normal, out vec3 color){
		float closestDist = 10000.0;
		vec3 uSphereCenters[1];
		uSphereCenters[0] = vec3(0.0, 0.0, 0.0);
		for (int i = 0; i < 0; i++) {
			float newDist;
			//TODO: take cube into consideration
			if(intersectSphere(uSphereCenters[i], lightStart, rayDir, newDist)){
				if(newDist < closestDist){
					closestDist = newDist;
					pos = lightStart + newDist * rayDir; //get the position in the world space
			      	normal = pos - uSphereCenters[i]; //calculate normal of the surface
			      	color = vec3(0.9, 0.9, 0.0); //the color of sphere is always white
				}
			}
		}

		float iNum = float(uInticesNumber);
		float vNum = float(uVerticesNumber);
		float iOffset = 0.5/iNum;
		float vOffset = 0.5/vNum;

		for (int i=0; i<2000000000; i++) {
			if(i >= uInticesNumber) break; //over signal
			vec3 intersectPoint, tri_norm;
			float cIndex = float(i)/iNum+iOffset; //add 1/3 to get correct index
			vec3 index = texture2D(uTriangleIndices, vec2(cIndex, 0.5)).xyz;
			vec3 A = texture2D(uTriangleVertices, vec2(float(index.x)/vNum+vOffset, 0.5)).xyz;
			vec3 B = texture2D(uTriangleVertices, vec2(float(index.y)/vNum+vOffset, 0.5)).xyz;
			vec3 C = texture2D(uTriangleVertices, vec2(float(index.z)/vNum+vOffset, 0.5)).xyz;

			if(intersectTriangle(A, B, C, lightStart, rayDir, intersectPoint)){
				if(intersectPoint.z < closestDist){
					closestDist = intersectPoint.z;
					//TODO: add cloud points
					pos = intersectPoint;
					//normal = tri_norm;
					color = vec3(0.0, 0.9, 0.0); //the color of sphere is always white
				}
			}
		}

		if(closestDist == 10000.0) return false;

		return true;
	} 

	void main(void){
		vec3 rayDir = normalize(vPixelPosition - uCameraPosition);

		vec3 pos, norm, color;
		vec3 colorFinal;
		vec3 colorObject, colorMirror;

		if (intersectWorld(uCameraPosition, rayDir, pos, norm, colorObject)) {
	      colorFinal = colorObject;
	      //colorFinal = lightAt(norm, -rayDir, colorObject);
	      colorMirror = (colorObject + vec3(0.7)) / 1.7; //TODO: tune it
	      rayDir = reflect(rayDir, norm);
	      //start light/ray reflection iteratively with limited times 
	      for (int i = 0; i < 0; i++) {
	      	if(intersectWorld(pos, rayDir, pos, norm, colorObject)){
	      		colorFinal += lightAt(norm, -rayDir, colorObject) * colorMirror;
	      		colorMirror *= (colorObject + vec3(0.7)) / 1.7; //TODO: tune it
	      		rayDir = reflect(rayDir, norm);
	      	}else{
	      		break;
	      	}
	      }
	      float n=1.0;//refraction index
	      float cosI=-1.0*dot(norm,rayDir);
	      float cosT2=1.0-n*n*(1.0-cosI*cosI);
	      vec3 nextPos;
	      vec3 refraColor;
	      if(cosT2>0)
	      {
	      	vec3 T=(n*ratDir)+(n*cosI-sqrt(cosT2))*norm;
	      	if(intersectWorld(pos, T, nextPos, norm, refraColor))
	      	{
	      		colorFinal += 0.5*refraColor;
	      	}
	      	
	      }
	      //colorFinal = vec3(0.0, 1.0, 1.0);
	      gl_FragColor = vec4(colorFinal, 1.0);
	    }else {
	      discard;
	      //gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); //background color
	    }
	}
</script>
</head>
<body bgcolor="#000000">
  <input id="loadObjbutton" type="file" style="visibility:hidden" />
  <div style="z-index:-1; text-align:center; width:100%; height:100%;">
  	<canvas id="canvas" style="border: none;"></canvas>
  </div>
<script type="text/javascript">
	//set up load file button
	document.getElementById('loadObjbutton').addEventListener('change', handleFileSelect, false);
	function handleFileSelect(evt) {
		var inputFile = evt.target.files[0]; 
		//check if it is obj file
		if(inputFile.name.indexOf(".obj") > -1){
			var reader = new FileReader();
			//load obj file
		    reader.onload = function(){
		      var objStr = reader.result;
		      var o = new OBJ.Mesh(objStr);
		      Scene.addObject(o);
		      drawScene(); //refresh
		      
		      //TODO: convert into cloud-points and feed into scene
		      //TODO: initialize rendering
		    };
		    reader.readAsText(inputFile);
		} 
	}

	//set up control pannel
	var controlPanel = function() {
	  this.adjustWidth = 5.0;
	  this.adjustHeight = 5.0;
	  this.loadFile = function() {document.getElementById('loadObjbutton').click()};
	};

	//page initialization
	window.onload = function() {
	  var controler = new controlPanel();
	  var gui = new dat.GUI();
	  gui.add(controler, 'adjustWidth', 0, 10).step(0.1);
	  gui.add(controler, 'adjustHeight', 0, 10).step(0.1);
	  gui.add(controler, 'loadFile').name('Load OBJ file');
	  //get init object
	  theObject = new OBJ.Mesh("res/teapot.obj");
	  webGLStart("canvas");
	};
</script>

</body>
</html>
